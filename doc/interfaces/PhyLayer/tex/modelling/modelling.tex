\newcommand{\h}[1]{\underline{#1}}
\newcommand{\bp}{BasePhyLayer}
\newcommand{\bm}{BaseMacLayer}


\section{modelling}

\emph{Note: }We denote a Layer in a general meaning by 'Phy-Layer' or 'MAC-Layer'
and our concrete C++ classes by \h{\bp} or \h{\bm}.


\subsection{overview}

Here we present the design- and interface details of the OMNeT-module \h{\bp} to meet the requirement specification. That includes:

\begin{enumerate}
 \item internal class diagram of \h{\bp} and relation to \h{\bm}
 \item interface description for all involved C++ classes
 \item flow charts for reception of MacPacket from upper layer and AirFrame from the channel
 \item some detailed flow charts for processes
\end{enumerate}


\subsection{classgraph}

We start with the classgraph for the OMNeT-module \h{\bp} that shows its
C++ classes, relations to other OMNeT-modules (especially \h{\bm})
and OMNeT-messages sent between them.

\begin{figure}[H]
 \centering
 \includegraphics[width = 0.8\textwidth]{modelling/class_diagram.png}
 \caption{class graph}
 \label{fig: classgraph}
\end{figure}


\subsection{The \h{\bp} interface}

In this section we focus on how one is able to communicate with the \h{\bp}, i.e. 
especially the \h{\bm} which is connected via an OMNeT-channel, OMNeT-controlchannel\req{provactive} and holds a reference to \h{\bp}\req{provpassive}.
\h{\bm} can obtain information about the channelstate, i.e. idle (boolean) or RSSI\req{channelstate} by a simple method call.

Further MAC-Layer is able to get\req{currentmode} and set\req{switchmode} the current mode (RX, TX, SLEEP) in \h{\bp} via method call.
\h{\bp} will change to switching state and schedule itself the appropriate timer for the switching interval\req{switchtimes}, \saf{mode state machine}.


\h{\bp} receives all necessary information for the sending process via MacToPhyControlInfo that is attached to MacPkt as control info by \h{\bm} and handed down.
MacPkt is send over the OMNeT-channel between MAC-Layer and Phy-Layer.

Further \h{\bp} sends messages of the kind TX\_OVER\req{txover} through the OMNeT-controlchannel
to \h{\bm} to signalize the end of a sending transmission.



\begin{figure}[H]
 \centering
 \includegraphics[width = \textwidth]{modelling/BasePhyLayer_members.png}
 \caption{BasePhyLayer interface}
 \label{fig: BasePhyLayer interface}
\end{figure}



\subsection{AnalogueModel and Signal}
\label{AM and Signal}

The Signal is designed one-dimensional (power-over-time) by default with a specified time point for start and end of the Signal. The owner is able
to add and request values at a specific time point\req{sendInfoTXPower}.
The Method getTimeIterator() return an appropriate SignalTimeIterator needed for applying AnalogueModels to the Signal.

\begin{quote}
\emph{NOTE: Anyone who subclasses Signal should make shure to have a properly
working SignalTimeIterator (subclassed) for it.}
\end{quote}

Further the Signal is set the packets header and payload bitrate\req{sendInfoBitrate},  the Move of the Host\req{sendInfoMove}, the size of the packet\req{sendInfoSize} and the channel to send the packet to\req{sendInfoChannel} by \h{\bp}.

\emph{See also \ref{AirFrame and Signal}.}

\begin{figure}[H]
 \centering
 \includegraphics[width = \textwidth]{modelling/AnalogueModel_members.png}
 \caption{analogue model interface}
 \label{fig: analogue model interface}
\end{figure}

The AnalogueModel offers functionality to filter a referenced signal\req{analogueFilter} in a specified interval\req{rcvFilterSignals} (e.g. preamble\req{rcvFilterPreamble}) and at a specific point in time. Therefore an appropriate SignalTimeIterator is needed!

Three basic AnalogueModel classes are foreseen to be plugged into Phy-Layer to simulate
pathloss\req{analogueSimPathloss}, shadowing\req{analogueSimShadowing} and fading
\req{analogueSimFading}.\\
\h{\bp} is designed to apply an arbitrary number of AnalogueModels to a Signal.

\begin{figure}[H]
 \centering
 \includegraphics[width = 0.8\textwidth]{modelling/apply_analogue_modells_detail.png}%[width=300pt]
 \caption{application of analogue models}
 \label{fig: application analogue models}
\end{figure}




\subsection{SNInfo and ChannelInfo}

ChannelInfo keeps track of all AirFrames on the channel. It does not differentiate between \textit{signal} and \textit{noise}. \h{\bp} is able to
add and remove references to certain AirFrames to ChannelInfo.\\
ChannelInfo is able to record the whole channel over time from a start to a stop signal and can return a vector of Signals (references) that intersect with a given time interval.\\
SNInfo is created by \h{\bp} when a packet arrives to collect all signals from the channel that intersect with the reception time interval of the packet.

\begin{figure}[H]
 \centering
 \includegraphics[width = \textwidth]{modelling/ChannelInfo_members.png}
 \caption{channel details}
 \label{fig: channel details}
\end{figure}




\subsection{Decider}

The Decider has two tasks:
\begin{enumerate}
	\item It decides whether we are able to receive a certain packet by evaluting
	the SNInfo for the packets preamble time interval, otherwise the packet will 	be considered noise\req{rcvClassify}
	\item When a packet has been received and is not noise the Decider 	returns a DeciderResult for that packet, that only contains (received) correct/not correct 	by default\req{rcvIsCorrect}.
\end{enumerate}

A Decider that gives a richer DeciderResult must be subclassed and implemented by the user.

\begin{figure}[H]
 \centering
 \includegraphics[width = \textwidth]{modelling/DeciderModule_members.png}
 \caption{Decider interface}
 \label{fig: Decider interface}
\end{figure}


\subsection{AirFrame}
\label{AirFrame and Signal}

AirFrame and Signal are both constructed by \h{\bp} with the help of MacToPhyControlInfo.
It is shown below how nessecary information for sending/receiving is distributed, Signal is already discussed in \ref{AM and Signal}.

\h{\bp} calculates duration\req{sendInfoDuration} and preamble duration\req{sendInfoPreambleDuration} of the packet and adds it to the AirFrame. Further every AirFrame has a unique id and a specific type.


\begin{figure}[H]
 \centering
 \includegraphics[width = \textwidth]{modelling/AirFrame_members.png}
 \caption{member arrangement in AirFrame and Signal}
 \label{fig: member AirFrame}
\end{figure}





\subsection{Receiving and processing an AirFrame}

The reception of an AirFrame is divided into:
\begin{enumerate}
	
	\item optional propagation delay\req{rcvSimDelay},
	\item reception of the preamble\req{rcvSimPreamble},
	\item application of AnalogueModels to the corresponding SNInfo\req{rcvSimAttenuation},
	\item decision whether packet is considered noise (Decider),
	\item reception of the packet.
\end{enumerate}

Afterwards the packet is either dropped (if considered noise) or processed. 

\begin{figure}[H]
 \centering
 \includegraphics[width = 0.8\textwidth]{modelling/onAirFrame.png}
 \caption{receiving process}
 \label{fig: receiving process}
\end{figure}

The receiving process is modelled internally by a state machine that schedules the
AirFrame that is received (since we have a pointer to it from the beginning) everytime
a delay/time interval shall be simulated. That saves us additional self-messages.


\begin{figure}[H]
 \centering
 \includegraphics[width = \textwidth]{modelling/receive_detail.png}
 \caption{receive detail}
 \label{fig: receive detail}
\end{figure}

When the preamble of a packet is completely received, \h{\bp} constructs a SNInfo
for the preamble, applies the AnalogueModels to it and passes it to the Decider to
find out whether this packet is considered noise.

\begin{figure}[H]
 \centering
 \includegraphics[width = 0.2\textwidth]{modelling/end_preamble_detail.png}
 \caption{end preamble detail}
 \label{fig: end preamble detail}
\end{figure}

In case a received packet is not \textit{noise} it is processed, i.e. \h{\bp} creates the corresponding SNInfo for the packet, applies AnalogueModels to it, passes the result to the Decider to check whether the packet was received correctly. If so, a MacPkt is created and handed up to Phy-Layer\req{rcvPassToMAC}.


\subsection{receiving a MacPkt}

On reception of a MacPkt from the MAC-Layer, \h{\bp} checks if:
\begin{enumerate}
	\item the radio is in TX mode\req{sendPreqMode},
	\item it is not already sending a packet\req{sendPreqSending} and
	\item the channel is idle\req{sendPreqIdle} (this is no hard requirement, \h{\bp} could send anyway).
\end{enumerate} 

If condition 1 or 2 is not fulfilled it will throw an error.\\

The MacToPhyControlInfo object attached to the MacPkt contains the information needed
by \h{\bp} when constructing Signal and AirFrame to send to the channel. Right now it contains:

\begin{enumerate}
	\item the channel for sending\req{sendCtrlChannel},
	\item header bitrate\req{sendCtrlHeaderBitrate},
	\item payload bitrate\req{sendCtrlBitrate},
	\item TX Power\req{sendCtrlTXPower} and
	\item the size of the packet\req{sendCtrlSize}.

\end{enumerate}



\begin{figure}[H]
 \centering
 \includegraphics[width = \textwidth]{modelling/MacToPhyCtrlInfo_members.png}
 \caption{MacToPhyControlInfo interface}
 \label{fig: MacToPhyCtrlInfo interface}
\end{figure}

\h{\bp} is responsilbe for creating AirFrame and Signal and attaching information (parameters) to them. For detailed arrangement of information in Signal and AirFrame see \ref{AirFrame and Signal}.
When the AirFrame is complete and sent, \h{\bp} shedules itself a TX\_OVER message
in order to know when to notify \h{\bm} that sending transmission is over (via control-message).

\begin{figure}[H]
 \centering
 \includegraphics[width = 0.8\textwidth]{modelling/onMACPkt.png}
 \caption{sending process}
 \label{fig: sending process}
\end{figure}


%\subsection{provide status information to MAC}

%Passively provided information\req{provpassive}: \h{\bm} is equipped with a reference to \h{\bp} in order to obtain information
%about channelstate\req{channelstate} and current mode\req{currentmode} by
%simple method calls. \\
%Actively provided information\req{provactive}: A cMessage of the kind TX\_OVER
%is sent to MAC-Layer when a sending transmission is over\req{txover}, \saf{sending process}.



%\subsection{send packets}

%Since \h{\bm} has a reference to \h{\bp} it can obtain information about the mode the radio is is currently in\req{sendPreqMode}, it is not already sending to the channel on its own\req{sendPreqSending} and the channel is idle\req{sendPreqIdle} via method calls, \saf{BasePhyLayer interface}.

%The class MacToPhyControlInfo is designed as the container for control info\req{packetFromMac} the MAC-Layer
%wants to attach to the packet given down to Phy-Layer for sending.
%The packet itself is handed down as a MacPkt via OMNeT-channel. 















