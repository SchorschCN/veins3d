[General]
network = sim
debug-on-errors = false
fname-append-host = false
**.module-eventlog-recording = false
**.vector-recording = true
#**.debug = false
num-rngs = 88
ned-path = ../../base;../../modules;../../examples;

# tkenv-default-run=1

# cmdenv-runs-to-execute=1
cmdenv-express-mode = true

##########################################################
#			Simulation parameters                        #
##########################################################
sim.**.coreDebug = false
sim.playgroundSizeX = 500
sim.playgroundSizeY = 500
sim.playgroundSizeZ = 500

##########################################################
#			WorldUtility parameters                      #
##########################################################
sim.world.useTorus = false
sim.world.use2D = false

##########################################################
#			         channel parameters                  #
##########################################################
#sim.channelControl.coreDebug = 0
sim.channelControl.sendDirect = false
sim.channelControl.pMax = 1000 mW
sim.channelControl.sat = -100 dBm
sim.channelControl.alpha = 2.0
sim.channelControl.carrierFrequency = 4500e+6 Hz

##########################################################
#             Host specific parameters                   #
##########################################################
#sim.*Node*.utility.coreDebug = 0

################ PhyLayer parameters #####################
sim.node[*].nic.phy.usePropagationDelay = false
sim.node[*].nic.phy.thermalNoise = 1.0
        
sim.node[*].nic.phy.timeRXToTX = 0.00021
sim.node[*].nic.phy.timeRXToSleep = 0.000031

sim.node[*].nic.phy.timeTXToRX = 0.00012
sim.node[*].nic.phy.timeTXToSleep = 0.000032

sim.node[*].nic.phy.timeSleepToRX = 0.000103
sim.node[*].nic.phy.timeSleepToTX = 0.000203

sim.node[*].nic.phy.PSleep = 0.01
sim.node[*].nic.phy.PTx = 1
sim.node[*].nic.phy.PSync = 100
sim.node[*].nic.phy.PRx = 30
sim.node[*].nic.phy.PSwitch = 10
sim.node[*].nic.phy.maxTXPower = 1 # useless but required by BasePhyLayer
sim.node[0].nic.phy.debug = true
***.debug = false
##########################################################
#                   hosts parameters                     #
##########################################################
sim.node[*].nic.connectionManagerName = "channelControl"

################ PhyLayer parameters #####################
sim.node[*].nic.phy.sensitivity = 0.1
sim.node[*].nic.phy.maxTXPower = 100.0

################ MAC parameters ##########################
sim.node[*].nic.mac.headerLength = 2 byte
sim.node[*].nic.mac.maxRetries = 1
sim.node[0].nic.mac.stats = true
sim.node[*].nic.mac.stats = false
sim.node[*].nic.mac.trace = false
sim.node[0].nic.mac.netaddress = 0
sim.node[1].nic.mac.netaddress = 1
sim.node[2].nic.mac.netaddress = 2
sim.node[3].nic.mac.netaddress = 3
sim.node[4].nic.mac.netaddress = 4
sim.node[5].nic.mac.netaddress = 5
sim.node[6].nic.mac.netaddress = 6
sim.node[7].nic.mac.netaddress = 7
sim.node[8].nic.mac.netaddress = 8
sim.node[9].nic.mac.netaddress = 9
sim.node[10].nic.mac.netaddress = 10

sim.node[*].nic.mac.debug = false
#sim.node[*].nic.mac.PulseMaxEnergy = 0.000074989 # -41.3 dBm/MHz
#sim.node[*].nic.mac.PulseMaxEnergy = 1 # 0 dBm / MHz



################ Application parameters ##################
sim.node[*].app.trafficParam = 1
sim.node[0].app.nodeAddr = 0
sim.node[1].app.nodeAddr = 1
sim.node[2].app.nodeAddr = 2
sim.node[3].app.nodeAddr = 3
sim.node[4].app.nodeAddr = 4
sim.node[5].app.nodeAddr = 5
sim.node[6].app.nodeAddr = 6
sim.node[7].app.nodeAddr = 7
sim.node[8].app.nodeAddr = 8
sim.node[9].app.nodeAddr = 9
sim.node[10].app.nodeAddr = 10

sim.node[*].app.debug = false
sim.node[*].app.flood = false

sim.node[*].app.stats = false
sim.node[*].app.trace = false
sim.node[*].app.payloadSize = 8 byte

## Nodes positions
sim.node[0].mobility.x = 0
sim.node[0].mobility.y = 0
sim.node[0].mobility.z = 0
sim.node[1].mobility.y = 0
sim.node[1].mobility.z = 0

[Config BERD]
sim.node[1].app.payloadSize = 8 byte
sim.node[*].app.dstAddr = 0
**.numHosts = 2
repeat = 10
sim.node[1].mobility.x = ${distance=10..100 step 10} #${distance=1, 2, 3, 4, 5, 6, 7, 8, 9, 10..100 step 10}
sim.node[0].app.nbPackets = 0

[Config BERDistance]
description = "Evaluates the bit error rate as a function of distance"
extends = BERD
sim.node[1].app.nbPackets = ${nbPackets=1000}
sim.node[*].nic.mac.RSDecoder = true
sim.node[*].nic.phy.analogueModels = xmldoc("channels/${Channel=ghassemzadeh-los,ghassemzadeh-nlos,cm1,cm2}.xml")
sim.node[*].nic.phy.decider = xmldoc("receivers/${Receiver=3dB}.xml")


[Config seg]
extends = BERD
description = "Evaluates the segment sync algorithm (UWBIREDSync) without interferers."
sim.node[1].app.nbPackets = ${nbPackets=100}
sim.node[*].nic.mac.RSDecoder = true
sim.node[*].nic.phy.analogueModels = xmldoc("channels/${Channel=ghassemzadeh-nlos}.xml")
sim.node[*].nic.phy.decider = xmldoc("receivers/${Receiver=3dBseg}.xml")

[Config Sensitivity]
description = "Evaluates the bit error rate as a function of distance and receiver settings."
extends = BERD
sim.node[1].app.nbPackets = ${nbPackets=1000}
sim.node[*].nic.mac.RSDecoder = true
sim.node[*].nic.phy.analogueModels = xmldoc("channels/${Channel=ghassemzadeh-nlos}.xml")
sim.node[*].nic.phy.decider = xmldoc("receivers/${Receiver=1dB,3dB,10dB}.xml")

[Config RS]
description = "Evaluates the BER with Reed-Solomon error correction."
extends = BERD
repeat = 1
sim.node[1].app.nbPackets = ${nbPackets=1000}
sim.node[*].nic.mac.RSDecoder = true
sim.node[*].nic.phy.analogueModels = xmldoc("channels/${Channel=ghassemzadeh-nlos}.xml")
sim.node[*].nic.phy.decider = xmldoc("receivers/${Receiver=3dB}.xml")

[Config waveforms]
description = "Generates some waveforms for illustration purposes."
extends = BERD
repeat = 1
sim.node[1].nic.mac.trace = true
sim.node[0].nic.mac.trace = true
sim.node[*].nic.mac.RSDecoder = true
sim.node[*].nic.phy.analogueModels = xmldoc("channels/${Channel=ghassemzadeh-los,ghassemzadeh-nlos,cm1,cm2,cm5}.xml")
sim.node[*].nic.phy.decider = xmldoc("receivers/${Receiver=3dB}-trace.xml")
sim.node[1].app.nbPackets = ${nbPackets=1}
sim.node[*].app.nbPackets = 0

[Config cmpPCM1D]
description = "Evaluates the BER on a line with an increasing density of jammers, similar to [rousselotuwb07]."
sim.node[*].mobility.y = 0
sim.node[*].mobility.z = 0
sim.node[0].mobility.x = 501
sim.node[0].app.nbPackets = 0
sim.node[1].mobility.x = 501+${d=120,60,30}
sim.node[*].app.payloadSize = 25 byte
sim.node[*].app.dstAddr = 0
sim.node[*].app.nbPackets = ${nbPackets=10}
sim.node[*].nic.mac.RSDecoder = true
sim.node[*].nic.phy.analogueModels = xmldoc("channels/${Channel=ghassemzadeh-los}.xml")
sim.node[0].nic.phy.decider = xmldoc("receivers/${Receiver=a1-3dB}.xml")
sim.node[*].nic.phy.decider = xmldoc("receivers/a999-3dB.xml")
repeat = 10
include cmpPCM1D_positions.ini
 

[Config MAICircle]
description = "Evaluates the impact of multiple access interference on bit error rate with homogeneous interferers"
sim.node[*].app.flood = true
sim.node[0].app.nbPackets = 0
sim.node[*].app.nbPackets = 100000
sim.node[0].app.nbPackets = 0
sim.node[*].app.payloadSize = 8 byte
sim.node[*].app.dstAddr = 0

[Config MAICircleN]
description = "Evaluates the BER as a function of the number of concurrent transmissions N at equal distance of the receiver"
extends = MAICircle
**.numHosts = ${NbNodes=2..6 step 1}
sim.node[*].nic.phy.analogueModels = xmldoc("channels/${Channel=ghassemzadeh-los}.xml")
sim.node[*].nic.phy.decider = xmldoc("../widemac/receivers/${Receiver=3dBAlwaysSync}.xml")
sim.node[0].mobility.x = ${O=100}
sim.node[0].mobility.y = ${O}
sim.node[1].mobility.x = ${O} + 5
sim.node[1].mobility.y =  ${O}

# The coordinates of the first jammer also define the iteration variable R
sim.node[2].mobility.x = ${O} 
sim.node[2].mobility.y =  ${O} + ${R=5}
sim.node[3].mobility.x = ${O}  - ${R}
sim.node[3].mobility.y =  ${O}
sim.node[4].mobility.x = ${O} 
sim.node[4].mobility.y =  ${O} - ${R}
sim.node[5].mobility.x = ${O} 
sim.node[5].mobility.y =  ${O}
sim.node[5].mobility.z =  2*${R}
sim.node[6].mobility.x = ${O} 
sim.node[6].mobility.y =  ${O}
sim.node[5].mobility.z =  0

sim.node[*].mobility.z = ${R}

#sim.node[2].mobility.x = ${O} + ${R=5}*uniform(-1,1)
#sim.node[2].mobility.y =  ${O} + sqrt(( this.x-${O} ) * ( this.x-${O} ) - 1 ) * (2*intuniform(0,1)-1)
#sim.node[3].mobility.x = ${O} + ${R}*uniform(-1,1)
#sim.node[3].mobility.y =  ${O} + sqrt( 1-(this.x-${O})*(this.x-${O}) ) * (2*intuniform(0,1)-1)
#sim.node[4].mobility.x = ${O} + ${R}*uniform(-1,1)
#sim.node[4].mobility.y =  ${O} + sqrt( 1-(this.x-${O})*(this.x-${O}) ) * (2*intuniform(0,1)-1)
#sim.node[5].mobility.x = ${O} + ${R}*uniform(-1,1)
#sim.node[5].mobility.y =  ${O} + sqrt( 1-(this.x-${O})*(this.x-${O}) ) * (2*intuniform(0,1)-1)
#sim.node[6].mobility.x = ${O} + ${R}*uniform(-1,1)
#sim.node[6].mobility.y =  ${O} + sqrt( 1-(this.x-${O})*(this.x-${O}) ) * (2*intuniform(0,1)-1)


[Config MAICircleR]
description = "Evaluates the BER between two nodes closely located as a function of the distance R to a large number of interferers"
# Requires threshold based synchronizer
repeat = 2
sim.node[*].app.nbPackets = 100 # smaller number of packets than usual because we have a larger number of transmitters
sim.node[*].nic.phy.analogueModels = xmldoc("channels/${Channel=ghassemzadeh-nlos}.xml")
sim.node[*].nic.phy.decider = xmldoc("receivers/${Receiver=3dB}.xml")
sim.node[1].app.dstAddr = 0
sim.node[*].app.dstAddr = 1000
include MAICircleR_positions.ini
extends = MAICircle

[Config MAIUnif]
description = "Evaluates the impact of multiple access interference on bit error rate with heterogeneous interferers"
repeat = 15

sim.node[*].nic.phy.analogueModels = xmldoc("channels/${Channel=ghassemzadeh-nlos}.xml")
sim.node[*].nic.phy.decider = xmldoc("receivers/${Receiver=3dB,1dB,10dB}.xml")

**.numHosts = ${NbNodes=3..11 step 1}

sim.node[0].app.nbPackets = 0
sim.node[0].app.flood = false

sim.node[*].app.flood = true
sim.node[*].app.nbPackets = 250
sim.node[*].app.payloadSize = 8 byte
sim.node[*].app.dstAddr = 0

# The receiver is located at the center of a grid

sim.node[0].mobility.x = 20
sim.node[0].mobility.y = 20
sim.node[0].mobility.z = 0

sim.node[1].mobility.x = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[1].mobility.y = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[1].mobility.z = 0

sim.node[2].mobility.x = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[2].mobility.y = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[2].mobility.z = 0

sim.node[3].mobility.x = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[3].mobility.y = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[3].mobility.z = 0

sim.node[4].mobility.x = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[4].mobility.y = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[4].mobility.z = 0

sim.node[5].mobility.x = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[5].mobility.y = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[5].mobility.z = 0

sim.node[6].mobility.x = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[6].mobility.y = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[6].mobility.z = 0

sim.node[7].mobility.x = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[7].mobility.y = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[7].mobility.z = 0

sim.node[8].mobility.x = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[8].mobility.y = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[8].mobility.z = 0

sim.node[9].mobility.x = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[9].mobility.y = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[9].mobility.z = 0

sim.node[10].mobility.x = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[10].mobility.y = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[10].mobility.z = 0

sim.node[11].mobility.x = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[11].mobility.y = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[11].mobility.z = 0

sim.node[12].mobility.x = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[12].mobility.y = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[12].mobility.z = 0

sim.node[13].mobility.x = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[13].mobility.y = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[13].mobility.z = 0

sim.node[14].mobility.x = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[14].mobility.y = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[14].mobility.z = 0

sim.node[15].mobility.x = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[15].mobility.y = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[15].mobility.z = 0

sim.node[16].mobility.x = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[16].mobility.y = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[16].mobility.z = 0

sim.node[17].mobility.x = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[17].mobility.y = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[17].mobility.z = 0

sim.node[18].mobility.x = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[18].mobility.y = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[18].mobility.z = 0

sim.node[19].mobility.x = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[19].mobility.y = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[19].mobility.z = 0

sim.node[20].mobility.x = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[20].mobility.y = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[20].mobility.z = 0

sim.node[21].mobility.x = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[21].mobility.y = 20 + uniform(0, 10) * (intuniform(0,1)*2-1)
sim.node[21].mobility.z = 0

